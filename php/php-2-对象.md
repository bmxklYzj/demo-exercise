# php-2-对象

1. 初识php对象: **1. 变量默认不能省略访问修饰符，函数默认可以省略且默认是public 2. 类内部变量定义使用$name， 在访问的时候则不需要$符号, ->name**

	```php
	// 注意：1. 变量默认不能省略访问修饰符，函数默认可以省略且默认是public
    // 2. 类内部变量定义使用$name， 在访问的时候则不需要$符号, ->name
    class classname {
        public $name;
        public $age;
        // 构造函数：在创建一个对象时调用，通常用来执行初始化的操作
        function __construct($name, $age) {
            echo "construct called! params is $name and $age";
            $this->name = $name;
            $this->age = $age;
        }
        // 析构函数：在销毁类之前执行一些操作或完成一些功能
        function __destruct() {
            echo 'destruct function called!';
        }
        function walk() {
            echo 'walk';
        }
        function eat() {
            echo 'eat';
        }
    }
    $person1 = new classname('yzj', 22);
    var_dump(
        $person1,   // object(classname)#1 (2) { ["name"]=> string(3) "yzj" ["age"]=> int(22) }
        $person1->name  // string(3) "yzj"
    );
    $person1->eat(); // eat
    $person1->walk(); // walk
	```
	
2. 通过`__get()/__set()`访问器来访问属性

	```php
	// __get()/__set()参考地址：http://www.cnblogs.com/glory-jzx/archive/2012/05/23/2514173.html
    /*
    总结：
    1. 从一个难以访问的属性读取数据的时候 __get() 方法被调用
    2. 向一个难以访问的属性赋值的时候 __set() 方法被调用
    3. 难以访问包括：（1）私有属性，（2）没有初始化的属性
    4. __isset() __unset() 也类似
    */
    class classname1 {
        private $a = 1;
        private $b = 2;
        public $c;
        public $d = 4;
        function __get($name)
        {
            echo 'get', $name;
        }
        function __set($name, $value)
        {
            echo 'set', $name;
        }
    }
    $person2 = new classname1();
    var_dump($person2->a); // geta
    var_dump($person2->b); // getb
    var_dump($person2->c); // NULL
    var_dump($person2->d); // int(4)
    var_dump($person2->e); // gete

    echo '<hr>';
    var_dump(
        $person2->a = 5, // seta
        $person2->c = 5, // 无输出
        $person2->f = 5 // setf
    );
	```
	
3. 关键字控制访问权限
	1. private：只能在类的内部访问
	2. public：能够在类的内部和外部都能访问
	3. protect：只能在类的内部访问，但是子类也能访问（即：继承了该类的子类也能访问到此属性）

	```php
	// private/protect/public
	class A {
	    public $name;
	    private function f1() {
	        echo "private function";
	    }
	    protected function f2() {
	        echo "protect function";
	    }
	    public function f3() {
	        echo "public function";
	    }
	}
	class B extends A {
	    function __construct() {
	        // $this->f1(); // Fatal error: Call to private method A::f1() from context 'B'
	        $this->f2(); // protect function
	        $this->f3(); // protect function
	    }
	}
	$b = new B();
	```

4. 类中属性和方法的重载。子类可以重载父类的属性和方法，类似于js中的原型链，子类的属性和方法优先级更加高，因此会覆盖父类元素。

	```php
	// 类的重载
	class C {
	    public $attribute = 1;
	    public function functionC () {
	        echo 'function c'.$this->attribute;
	    }
	}
	
	class D extends C {
	    public $attribute = 2;
	    public function functionC()
	    {
	        echo 'function d'.$this->attribute;
	        parent::functionC(); // TODO: Change the autogenerated stub
	    }
	}
	
	$d = new D();
	$d->functionC(); // function d2function c2
	//$d->parent::functionC(); // 错误:不能这样用,只能在子类中使用parent::funcName()的方式来访问父类的方法
	```
	

5. 在类中使用final关键字，有两个用处：

	1. 禁止类被继承；
	2. 禁止方法被重载 (注：对属性没有限制)
	
6. 实现接口：php中不支持多重继承（即：不能继承多个父类，只能继承自一个父类。一个父类可以有多个子类），可以通过实现接口实现多重继承。

	```php
	// 实现接口
	interface E {
	    function interface_func(); // 注意接口的写法,这里的函数没有函数体
	}
	
	class F implements E {
	    function interface_func()
	    {
	        echo 'interface';
	    }
	}
	
	$f = new F();
	$f->interface_func(); // interface
	```
