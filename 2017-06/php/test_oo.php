<?php
// 第六章：php面向对象

// 注意：1. 变量默认不能省略访问修饰符，函数默认可以省略且默认是public
// 2. 类内部变量定义使用$name， 在访问的时候则不需要$符号, ->name

echo 1;
echo 2;
class classname0 {
    public $name;
    public $age;
    // 构造函数：在创建一个对象时调用，通常用来执行初始化的操作
    function __construct($name, $age) {
        echo "construct 0 called! params is $name and $age";
        $this->name = $name;
        $this->age = $age;
    }
    // 析构函数：在销毁类之前执行一些操作或完成一些功能
    function __destruct() {
        echo 'destruct 0 function called!';
    }
    function walk() {
        echo 'walk';
    }
    function eat() {
        echo 'eat';
    }
}
$person0 = new classname0('yzj', 22);
var_dump(
    $person0,   // object(classname)#1 (2) { ["name"]=> string(3) "yzj" ["age"]=> int(22) }
    $person0->name  // string(3) "yzj"
);
$person0->eat(); // eat
$person0->walk(); // walk

echo '<hr>';
// __get()/__set()参考地址：http://www.cnblogs.com/glory-jzx/archive/2012/05/23/2514173.html
/*
总结：
1. 从一个难以访问的属性读取数据的时候 __get() 方法被调用
2. 向一个难以访问的属性赋值的时候 __set() 方法被调用
3. 难以访问包括：（1）私有属性，（2）没有初始化的属性
4. __isset() __unset() 也类似
*/
class classname1 {
    private $a = 1;
    private $b = 2;
    public $c;
    public $d = 4;
    function __get($name)
    {
        echo 'get', $name;
    }
    function __set($name, $value)
    {
        echo 'set', $name;
    }
}
$person2 = new classname1();
var_dump($person2->a); // geta
var_dump($person2->b); // getb
var_dump($person2->c); // NULL
var_dump($person2->d); // int(4)
var_dump($person2->e); // gete

echo '<hr>';
var_dump(
    $person2->a = 5, // seta
    $person2->c = 5, // 无输出
    $person2->f = 5 // setf
);
echo "hellohello";
for ($i = 0; $i < 5; $i++) {
    $t = $i + 1;
    echo $t;
}


echo '<hr>';
// private/protect/public
class A {
    public $name;
    private function f1() {
        echo "private function";
    }
    protected function f2() {
        echo "protect function";
    }
    public function f3() {
        echo "public function";
    }
}
class B extends A {
    function __construct() {
        // $this->f1(); // Fatal error: Call to private method A::f1() from context 'B'
        $this->f2(); // protect function
        $this->f3(); // public function
    }
}
$b = new B();


echo '<hr>';
// 类的重载
class C {
    public $attribute = 1;
    public function functionC () {
        echo 'function c'.$this->attribute;
    }
}

class D extends C {
    public $attribute = 2;
    public function functionC()
    {
        echo 'function d'.$this->attribute;
        parent::functionC(); // TODO: Change the autogenerated stub
    }
}

$d = new D();
$d->functionC(); // function d2function c2
//$d->parent::functionC(); // 错误:不能这样用,只能在子类中使用parent::funcName()的方式来访问父类的方法


echo '<hr>';
// 实现接口
interface E {
    function interface_func(); // 注意接口的写法,这里的函数没有函数体
}

class F implements E {
    function interface_func()
    {
        echo 'interface';
    }
}

$f = new F();
$f->interface_func(); // interface


?>